---
title: שפות תכנות, אוי לא, מה אני צריך את הצרה הזו
date: 2019-12-31
thumb: "windows-7.jpg"
---
חסם כניסה די גבוה לפיתוח על שרשרת בלוקים הוא הצורך ללמוד שפה חדשה. שפות תכנות יש הרבה, אני מכיר די טוב PHP, פייטון, ג'אווהסקריפט, ויזואל בייסיק, SQL ו- #C. כשאני אומר "די טוב" זה אומר שפיתחתי קוד בשפות האלו למחייתי כך שיש לי היזון חוזר ממקור חיצוני שהייתי "די טוב" כשעבדתי עם השפות הללו. בעבר הרחוק עבדתי גם עם ++C אך זה היה לפני יותר מ 20 שנה (אני לא מאמין כמה שהזמן טס מהר!).
 
בעולם של שרשראות הבלוקים הופתעתי לגלות שמשתמשים בשפות ישנות כמו C או ++C לפיתוח התשתית הבסיסית. אולי זה לא צריך להפתיע, כל תשתית בסיסית, או יותר נכון - רוב התשתיות הבסיסיות נכתבות ב ++C או ב C. נמאס לי לכתוב ++C או C ואני אערבב ביניהן ולא אכתוב יותר את שתי הצורות, הן דומות מספיק אחת לשניה ביתרונות ובחסרונות.
 
מערכות הפעלה כמו ווינדווס או לינוקס כתובות ב C, מערכות שרתים לניהול בסיסי נתונים כתובות ב C, דפדפנים, מעבדי תמלילים וגיליונות אלקטרונים כתובים ב C, אפילו שפות תכנות כתובות ב C. כן, ג'אווהסקריפט, ג'אווה, #C, פייטון וכמעט כל השפות המוכרות כתובות ב C. אפילו C כתובה ב C, ואני לא מתכוון לזה ש ++C כתובה ב C, אלא שהשפה ממש, C - כתובה ב C והשפה ++C כתובה ב ++C.
 
ברור שבהתחלה זה לא היה ככה, אבל כיום כשרוצים להרחיב את השפה, או לכתוב גירסה חדשה שלה, עושים זאת בעזרת הגירסה הנוכחית שלה.
 
אז כדי להבין איך ביטקוין עובד, לא מקריאת ההסברים באנגלית או אפילו מהדף הלבן המקורי של סטושי נקמוטו, אלא ממש להבין איך זה עובד, אין ברירה, צריך לקרוא את קוד המקור של ביטקוין. כיום יש גירסאות שכתובות בשפות אחרות אך כדאי לעשות פעם מסע ארכיאולוגי לנבכי ההיסטוריה של הגירסאות הראשונות של ביטקוין. הן פשוטות יותר מהגירסאות המודרניות וקל יותר לעקוב אחרי החלקים, יש פחות חלקים זזים.
 
חוץ מההיסטוריה והארכיאולוגיה, ++C היא השפה של החוזים החכמים על איאוס, שרשרת הבלוקים המתקדמת והמתאימה ביותר לפיתוח מערכות שרת שלמות. לא צריך להירתע מהשפה הקשה, יש כמה נסיבות מקלות וכמה סיבות טובות לבחירה הזו. בנוסף מכיוון שהקוד לא מתקמפל לשפת מכונה ממש, אלא לקוד ביניים שרץ על מכונה וירטואלית סטנדרטית WASM שמשתמשת בחלק מצומצם של ג'אווהסקריפט ורץ כמעט במהירות של שפת מכונה, יש אפשרות לפתח בשפות אחרות שמתקמפלות לאותה שפת ביניים אך מומלץ לעבוד עם ++C כי היא תהיה היעילה ביותר. יעילות היא השיקול החשוב ביותר למפתחי איאוס כי בשרשרת הבלוקים הזו יעילות חישובית היא נושא חשוב. כדי להגיע ליכולת עיבוד של עשרות אלפי טרנזקציות בשניה, חשוב לא לבזבז אף מחזור עיבוד במעבד הראשי של המחשב של השרת הנוכחי בשרשרת הבלוקים.
 
החיסרון הגדול של ++C לעומת שפות תכנות פופולריות כיום הוא שהמפתח צריך לדאוג בעצמו לניהול הזיכרון. ++C נותנת כח גדול, וכמו כל מי שמכיר את ספיידרמן יודע שעם כח גדול באה אחריות גדולה. החדשות הטובות באיאוס הן שלא באמת צריך לדאוג לגבי דליפות זיכרון כי כל פעם שמישהו קורא לפעולה בחוזה החכם שלנו, התכנית של החוזה החכם נטענת לזיכרון, מבוצעת וכל המשתנים שלנו נעלמים ומנוקים על ידי המכונה הוירטואלית שמריצה את החוזה החכם. זה דומה לPHP שגם אם יש באג באחת הפונקציות שלנו, השרת ממשיך להריץ את החלקים האחרים של הקוד שלנו. 
 
בנוסף, לא באמת צריך ללמוד את כל מה שיש בשפה המסובכת והמתקדמת והלא-סלחנית ++C. ניתן בהחלט להשתלט במהירות על החלקים הרלוונטיים לפיתוח חוזה חכם על ידי רענון הידע בחלק מצומצם מאוד של השפה, ואם אתם מכירים שפת תכנות אחרת, יש לכם קרש קפיצה גדול ומשמעותי. כל מה שצריך זה לדעת אין עובדים עם משתנים, כולל סוגי המשתנים הבסיסיים, איך מגדירים עצמים המורכבים מכמה סוגי משתנים בסיסיים, איך מנהלים אוספים - טבלאות שחיות בזיכרון RAM כי זה הכי מהיר לשליפה ולעדכון, עד פי מאה אלף מזיכרון שנשמר בכונן קשיח!
 
אז אני חושב שזה אחד מהפוסטים האחרונים שהוא ברובו טקסט בעברית ובקרוב אתחיל להוסיף קוד אמיתי ב ++C אך עדיין אקשט אותו בהרבה הסברים בעברית.
 
אני מקווה שבקרוב אוכל לייצר מילון פשוט של קוד בג'אווהסקריפט מול קוד ++C שעושה דברים דומים. מילון שמתרגם דוגמאות של קוד טיפוסי שחוזר על עצמו הוא כלי טוב, כי אם אתם יודעים לבטא את עצמכם בשפה אחת כמו ג'אווהסקריפט ויכולים להביע את הרעיון של החוזה החכם בשפה זו, תוכלו להשתמש בדוגמאות כדי להבין מה צריך לעשות כדי לממש את הרעיון ב ++C.
 
בתור חימום, קחו בחשבון שכתיבת חוזה חכם דורשת דיוק ולא ניתן להשתמש בסוגי משתנים כלליים כמו בג'אוהסקריפט כמו "מספר", צריך לבחור סוג מספר ספציפי. בהתחלה לא צריך להתלבט יותר מידי זמן עם שיקולים בעד ונגד כל סוג, ולא צריך ללמוד את כל הסוגים האפשריים ב ++C. מספיק להכיר כמה סוגים ולדעת לאיזה מקרה כל סוג מתאים. אפילו int לא מספיק ספציפי בשפה ותלוי בסביבה או במעבד של המחשב. לכן בפיתוח חוזה חכם על איאוס משתמשים בשמות יותר מפורטים וישירים למשתנים אפילו לצנועים שבמספרים הטבעיים, למשל uint64_t.
משתנה מסוג uint64_t הוא לא סתם מספר שלם, הוא מספר שלם ללא סימן כך שלא יכול להיות שלילי והוא משתמש ב 64 סיביות כך שהוא די גדול בתחום הערכים האפשריים בו.
 
יש טריק לקבלת מושג של גודל המשתנה ולתרגום מסיביות או ביטים למספרים עשרוניים שבני אנוש רגילים לדבר עליהם, הטריק מתבסס על צירוף המקרים המוזר שבו שתיים בעשירית שווה 1024 שזה ממש קרוב לאלף.
 
כך שניתן לקחת את מספר הביטים במספר, לחלק בעשר ואז לכפול פי שלוש ולקבל קירוב טוב של המספר הגדול ביותר שיכול להיכנס לסוג המשתנה שלנו.
 
למשל uint32_t יכול להכיל מספרים טבעיים, אפס ומספרים שלמים חיוביים, עד בערך מיליארד, שזה אחד עם 9 אפסים אחריו. כי 32 לחלק לעשר זה 3 וכפול שלוש זה 9.
 
חישוב דומה ל uint64_t מראה שפי שתיים ביטים במשתנה שלנו יתנו פי שתיים אפסים אחרי האחד במספר הגדול ביותר שמשתנה מסוג זה יכול להכיל, לא שני מיליארד, אלא 1 עם 18 אפסים אחריו. שיפור גדול!
 
בפוסט הבא ארחיב על הנושא.

